<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gam0022.net</title>
    <link>https://gam0022.net/tags/shader/index.xml</link>
    <description>Recent content on gam0022.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>jp</language>
    <copyright>&amp;copy; 2021 gam0022</copyright>
    <atom:link href="/tags/shader/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Object Space Raymarching in Unreal Engine 5.2</title>
      <link>https://gam0022.net/blog/2023/07/31/raymarching-in-ue5/</link>
      <pubDate>Mon, 31 Jul 2023 10:00:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2023/07/31/raymarching-in-ue5/</guid>
      <description>&lt;p&gt;これは&lt;a href=&#34;https://sites.google.com/view/rtcamp9/home&#34;&gt;レイトレ合宿9&lt;/a&gt;のアドベントカレンダーの記事です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;あまりレイトレに関連しないテーマですが、レイは飛ばしているので大目に見てください&lt;/li&gt;
&lt;li&gt;レイトレ合宿ではレンダラーを自作する必要があるため、ゲームエンジンは使えません&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/RaymarchingInUE5_thumbnail_v7.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/RaymarchingInUE5_thumbnail_v7.jpg&#34; alt=&#34;Object Space Raymarching in Unreal Engine 5.2&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;Unreal Engine 5.2上でオブジェクトスペースのレイマーチングを実装したので、その解説をします。&lt;/p&gt;

&lt;p&gt;レイマーチングをノードだけで実装するのは大変なので、MaterialのCustomノードを用いて複雑な処理はHLSLのコードで実装しました。&lt;/p&gt;

&lt;p&gt;UE（Unreal Engine）のプロジェクトはGitHubに公開しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/RaymarchingInUE5/&#34;&gt;github.com/gam0022/RaymarchingInUE5/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Object Space Raymarching in Unreal Engine 5.2&lt;a href=&#34;https://twitter.com/hashtag/UE5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UE5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/Shader?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Shader&lt;/a&gt; &lt;a href=&#34;https://t.co/42n2W87HnJ&#34;&gt;pic.twitter.com/42n2W87HnJ&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1684596333209075712?ref_src=twsrc%5Etfw&#34;&gt;July 27, 2023&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Randomization of glowing animation borders&lt;a href=&#34;https://twitter.com/hashtag/UE5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UE5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/UnrealEngine5?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#UnrealEngine5&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/Shader?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Shader&lt;/a&gt; &lt;a href=&#34;https://t.co/FvLbVtE9Q3&#34;&gt;pic.twitter.com/FvLbVtE9Q3&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1685583942920089600?ref_src=twsrc%5Etfw&#34;&gt;July 30, 2023&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;読者対象&#34;&gt;読者対象&lt;/h2&gt;

&lt;p&gt;この記事は以下の読者を対象としています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1週間前の自分&lt;/li&gt;
&lt;li&gt;レイマーチングやシェーダーの実装経験はあるが、UEは初心者の方&lt;/li&gt;
&lt;li&gt;UEのカスタムシェーダーやMaterial Editorに興味がある方&lt;/li&gt;
&lt;li&gt;UE上でノードでは難しい複雑なシェーダーを実装してみたい人&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;まずは実装結果を紹介します。&lt;/p&gt;

&lt;h3 id=&#34;オブジェクトスペースのレイマーチング&#34;&gt;オブジェクトスペースのレイマーチング&lt;/h3&gt;

&lt;p&gt;オブジェクトスペースのレイマーチングを実装しました。カスタムシェーダーをCubeに適用し、レイマーチングを行います。Cubeをレイマーチングのバウンディングボックスとして使用します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/object_space_raymarching_v1.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/object_space_raymarching_v1.png&#34; alt=&#34;オブジェクトスペースのレイマーチング&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;オブジェクトスペースにすることで、フルスクリーンのレイマーチングと比較して処理負荷を抑えることができます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラではなくCubeの表面からレイを飛ばすことで、レイマーチングの衝突判定を少ないイテレーション回数に抑えられる&lt;/li&gt;
&lt;li&gt;レイマーチングの負荷の高いシェーダーの描画範囲を制限できる&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;パラメーターのリアルタイム編集&#34;&gt;パラメーターのリアルタイム編集&lt;/h3&gt;

&lt;p&gt;レイマーチングによる描画を行っているため、フラクタルのパラメーターをリアルタイムに編集できます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v1.gif&#34; alt=&#34;IFSパラメーターのアニメーション1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v2.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/param_v2.gif&#34; alt=&#34;IFSパラメーターのアニメーション2&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;▲グローのアニメーションのボーダーを乱数で散らしたバージョン&lt;/p&gt;

&lt;h3 id=&#34;actorのトランスフォームに追従&#34;&gt;Actorのトランスフォームに追従&lt;/h3&gt;

&lt;p&gt;オブジェクトスペースのレイマーチングの実装のため、Actor（UnityのGameObjectに相当）のトランスフォームに追従します。&lt;/p&gt;

&lt;h4 id=&#34;平行移動&#34;&gt;平行移動&lt;/h4&gt;

&lt;p&gt;平行移動の結果を見ると、UEのレンダリング結果と統合できていることがわかります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;他のオブジェクトと相互にライティングの影響を受けている&lt;/li&gt;
&lt;li&gt;床に反射し、ライティング結果が周囲に自然に馴染んでいる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_translation_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_translation_v1.gif&#34; alt=&#34;平行移動&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;回転&#34;&gt;回転&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_rotation_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_rotation_v1.gif&#34; alt=&#34;回転&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;拡大縮小&#34;&gt;拡大縮小&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_scale_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/transform_scale_v1.gif&#34; alt=&#34;拡大縮小&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;実装の流れ&#34;&gt;実装の流れ&lt;/h2&gt;

&lt;p&gt;以下は実装の流れです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UE上のHLSL（.ush）シェーダー開発環境の構築

&lt;ul&gt;
&lt;li&gt;C++の開発環境のセットアップ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddShaderSourceDirectoryMapping&lt;/code&gt; を使用してシェーダーを配置するディレクトリを登録&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UE上のレイマーチングの実装

&lt;ul&gt;
&lt;li&gt;HLSL（.ush）でレイマーチングを実装&lt;/li&gt;
&lt;li&gt;MaterialのCustomノードの &lt;code&gt;Include File Paths&lt;/code&gt; にHLSLシェーダー（.ush）を指定し、レイマーチングの関数を呼び出す&lt;/li&gt;
&lt;li&gt;Customノードの計算結果をResultノードに出力し、ライティング計算はエンジン側に任せる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;発展的な内容

&lt;ul&gt;
&lt;li&gt;オブジェクトスペースのレイマーチングに対応&lt;/li&gt;
&lt;li&gt;レイマーチングの空間にカメラが潜った場合を考慮&lt;/li&gt;
&lt;li&gt;他のオブジェクトの前後関係の解消&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hlsl-ush-によるシェーダー開発環境の構築&#34;&gt;HLSL（.ush）によるシェーダー開発環境の構築&lt;/h2&gt;

&lt;p&gt;Unityでは、シェーダーファイル（.shader）をAssetsフォルダーに配置するだけで認識されますが、UEではシェーダーを明示的に配置するディレクトリをエンジンに認識させる必要があります。&lt;/p&gt;

&lt;p&gt;シェーダーを書くためにC++のコードを記述する必要があるのは面倒ですが、仕方ありませんね。&lt;/p&gt;

&lt;p&gt;C++の関数である&lt;a href=&#34;https://docs.unrealengine.com/5.2/en-US/API/Runtime/RenderCore/AddShaderSourceDirectoryMapping/&#34;&gt;AddShaderSourceDirectoryMapping&lt;/a&gt;を呼び出すことで、エンジンがHLSLシェーダー（.ush）を認識できるようになります。&lt;/p&gt;

&lt;p&gt;まずは、C++の開発環境を整える必要があります。以下の記事を参考に、UE用のC++の開発環境をセットアップしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zenn.dev/posita33/books/ue5_starter_cpp_and_bp_001/viewer/chap_01_vs2022_setup&#34;&gt;Visual Studio 2022のセットアップ｜Unreal Engine 5から始める C++ &amp;amp; Blueprint&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C++の開発環境をセットアップしたら、次の記事の「普通の方法」を参考にして、AddShaderSourceDirectoryMappingを呼び出してシェーダーを配置するディレクトリをエンジン側に登録します。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/takaf51/items/cd98bd83fe5965d0de30#%E6%99%AE%E9%80%9A%E3%81%AE%E6%96%B9%E6%B3%95&#34;&gt;UE4,5 プロジェクトファイル内の外部シェーダーファイル(usf, ush, hlsl)をインクルードする為の設定。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;手順を箇条書きにすると以下のようになります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C++プロジェクト化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;プロジェクト名.Build.cs&lt;/code&gt; に &lt;code&gt;RenderCore&lt;/code&gt; への依存関係を追加&lt;/li&gt;
&lt;li&gt;プロジェクトにモジュール開始と終了の関数を追加&lt;/li&gt;
&lt;li&gt;モジュール開始のStartupModule()に下記のコードを追加&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;FString ShaderDir = FPaths::Combine(FPaths::ProjectDir(), &amp;quot;Shaders&amp;quot;);
AddShaderSourceDirectoryMapping(&amp;quot;/Project&amp;quot;, ShaderDir);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードにより、プロジェクトの直下にある &lt;code&gt;Shaders&lt;/code&gt; ディレクトリに配置されたHLSLシェーダー（.ush）をエンジン側からIncludeできるようになります。&lt;/p&gt;

&lt;h3 id=&#34;余談-昔のueでhlslの関数定義やincludeは大変だった&#34;&gt;余談：昔のUEでHLSLの関数定義やincludeは大変だった&lt;/h3&gt;

&lt;p&gt;過去のUEでは、HLSLをIncludeすることができず、Customノードの展開される仕様を利用して、関数定義や#includeをインジェクションする必要があったようです。&lt;/p&gt;

&lt;p&gt;これは大変ですね。エンジンの改善により、HLSLのシェーダー開発がより使いやすくなったことは、喜ばしい進化と言えるでしょう。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;もんしょさんと話していたのは、カスタムノードをカッコで閉じちゃえば、あとは自由にコード書けちゃうぜ！というネタです。&lt;br&gt;実はこのTweetのマテリアルもこれを使用して書かれています。&lt;a href=&#34;https://t.co/y3P8BkDWyw&#34;&gt;https://t.co/y3P8BkDWyw&lt;/a&gt; &lt;a href=&#34;https://t.co/M4M5WX4u7m&#34;&gt;pic.twitter.com/M4M5WX4u7m&lt;/a&gt;&lt;/p&gt;&amp;mdash; Takuro Kayumi (@TakuroKX) &lt;a href=&#34;https://twitter.com/TakuroKX/status/670292440369094656?ref_src=twsrc%5Etfw&#34;&gt;November 27, 2015&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://monsho.hatenablog.com/entry/2015/12/23/120142&#34;&gt;Customノード3分ハッキング - もんしょの巣穴ブログ Ver2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pafuhana1213.hatenablog.com/entry/2015/02/15/152312&#34;&gt;UE4のCustomノード(カスタムHLSLシェーダ)を使ってみた - ぼっちプログラマのメモ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;material全体&#34;&gt;Material全体&lt;/h2&gt;

&lt;p&gt;次の画像はMaterialのグラフ全体です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_all_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_all_text.png&#34; alt=&#34;マテリアル全体&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このグラフでは、レイマーチングの処理をHLSLで実装し、Customノードから呼び出しています。&lt;/p&gt;

&lt;p&gt;ノードとしては以下の処理のみ実装しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラのレイの生成&lt;/li&gt;
&lt;li&gt;前後関係の解消のためのPixel Depth Offsetの計算&lt;/li&gt;
&lt;li&gt;Emissiveのパターン計算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、オブジェクトスペースのレイマーチングを行うための座標系の計算もノードで行われています。レイマーチングのCustomノードの前後にはTransformノードが接続されています。&lt;/p&gt;

&lt;h2 id=&#34;hlslシェーダーでレイマーチングを実装&#34;&gt;HLSLシェーダーでレイマーチングを実装&lt;/h2&gt;

&lt;p&gt;MaterialのCustomノードのDetailsからInclude File Pathsを指定し、HLSLファイル（.ush）をインクルードします。&lt;/p&gt;

&lt;p&gt;このとき「実際のファイルパス」と「Include File Paths」の指定に違いがある点に注意してください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ファイルパスの例: &lt;code&gt;D:\UnrealProjects\プロジェクト名\Shaders\Raymarching.ush&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Include File Paths: &lt;code&gt;/Project/Raymarching.ush&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Raymarching.ush&lt;/code&gt; のHLSLコードの実装例は以下の通りです。レイマーチングの基本的な実装方法については説明しません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#pragma once

float sdBox(float3 p, float3 b)
{
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// メンガーのスポンジの距離関数
float dMenger(float3 z0, float3 offset, float scale, inout float4 ifsPosition)
{
    float4 z = float4(z0, 1.0);

    [loop]
    for (int n = 0; n &amp;lt; 4; n++)
    {
        z = abs(z);

        if (z.x &amp;lt; z.y) z.xy = z.yx;
        if (z.x &amp;lt; z.z) z.xz = z.zx;
        if (z.y &amp;lt; z.z) z.yz = z.zy;

        z *= scale;
        z.xyz -= offset * (scale - 1.0);

        if (z.z &amp;lt; - 0.5 * offset.z * (scale - 1.0))
        {
            z.z += offset.z * (scale - 1.0);
        }
    }

    ifsPosition = z;

    return (length(max(abs(z.xyz) - float3(1.0, 1.0, 1.0), 0.0)) - 0.05) / z.w;
}

float map(float3 pos, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    pos /= uniformScale;

    float d = dMenger(pos, mengerOffst, mengerScale, ifsPosition);
    d *= uniformScale;

    return d;
}

// 偏微分から法線を計算
float3 calcNormal(float3 p, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    float eps = 0.001;

    return normalize(float3(
        map(p + float3(eps, 0.0, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition) - map(p + float3(-eps, 0.0, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition),
        map(p + float3(0.0, eps, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition) - map(p + float3(0.0, -eps, 0.0), uniformScale, mengerOffst, mengerScale, ifsPosition),
        map(p + float3(0.0, 0.0, eps), uniformScale, mengerOffst, mengerScale, ifsPosition) - map(p + float3(0.0, 0.0, -eps), uniformScale, mengerOffst, mengerScale, ifsPosition)
    ));
}

// Ambient Occlusionを計算
float calcAO(float3 pos, float3 nor, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    float occ = 0.0;
    float sca = 1.0;

    for (int i = 0; i &amp;lt; 5; i++)
    {
        float h = 0.01 + 0.12 * float(i) / 4.0;
        float d = map(pos + h * nor, uniformScale, mengerOffst, mengerScale, ifsPosition);
        occ += (h - d) * sca;
        sca *= 0.95;
        if (occ &amp;gt; 0.35) break;
    }

    return saturate(clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y));
}

// エッジを計算
float calcEdge(float3 p, float uniformScale, float3 mengerOffst, float mengerScale, inout float4 ifsPosition)
{
    float edge = 0.0;
    float2 e = float2(0.01, 0);

    float d1 = map(p + e.xyy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d2 = map(p - e.xyy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d3 = map(p + e.yxy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d4 = map(p - e.yxy, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d5 = map(p + e.yyx, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d6 = map(p - e.yyx, uniformScale, mengerOffst, mengerScale, ifsPosition);
    float d = map(p, uniformScale, mengerOffst, mengerScale, ifsPosition) * 2.;

    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    edge = smoothstep(0., 1., sqrt(edge / e.x * 2.));

    return edge;
}

// 原点にあるサイズが100x100x100のCubeの内部にいるかどうかを判定
float isInsideCube(float3 p)
{
    return sdBox(p, (50).xxx) &amp;lt;= 0;
}

void raymarching(
    // Inputs
    float3 origin, float3 ray, int raymarchingLoop,
    float uniformScale, float3 mengerOffst, float mengerScale,

    // Additional Outpus
    inout float hit, inout float depth, inout float3 hitPosition, inout float4 ifsPosition,
    inout float3 albedo, inout float3 normal, inout float ao, inout float emissive
)
{
    // レイマーチング
    hit = 0;
    depth = 0.0;// レイの進んだ距離
    float3 p = origin;// レイの先端の座標
    int i = 0;// レイマーチングのループカウンター

    [loop]
    for (i = 0; i &amp;lt; raymarchingLoop; i++)
    {
        float d = map(p, uniformScale, mengerOffst, mengerScale, ifsPosition);

        // 最短距離を0に近似できるなら、オブジェクトに衝突したとみなして、ループを抜けます
        if (abs(d) &amp;lt; 0.1)
        {
            break;
        }

        depth += d;// 最短距離だけレイを進めます
        p = origin + ray * depth;// レイの先端の座標を更新します
    }

    // バウンディングボックスの中にレイが留まっていればヒットしたと判定
    hit = isInsideCube(p);
    hitPosition = p;

    float4 _ifsPosition;

    if (hit)
    {
        // ライティングのパラメーター
        normal = calcNormal(p, uniformScale, mengerOffst, mengerScale, _ifsPosition);// 法線
        emissive = calcEdge(p, uniformScale, mengerOffst, mengerScale, _ifsPosition);// エッジ
        ao = calcAO(p, normal, uniformScale, mengerOffst, mengerScale, _ifsPosition);// AO
    }
    else
    {
        albedo = float3(0, 0, 0);
        discard;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;customノードのdetails&#34;&gt;CustomノードのDetails&lt;/h2&gt;

&lt;p&gt;CustomノードのDetailsは以下のように設定します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_custom_details.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_custom_details.png&#34; alt=&#34;CustomノードのDetails&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CustomノードのCodeでは、raymarhcing関数を呼び出します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;albedo = objectAlbedo;

raymarching(
    origin, ray, raymarchingLoop,
    uniformScale, mengerOffst, mengerScale,
    hit, depth, hitPosition, ifsPosition,
    albedo, normal, ao, emissive
);

return albedo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Inputs&lt;/code&gt;と&lt;code&gt;Additional Outpus&lt;/code&gt;には、&lt;code&gt;Raymarching.ush&lt;/code&gt;の&lt;code&gt;raymarching&lt;/code&gt;関数の全パラメーターを指定します。&lt;/p&gt;

&lt;p&gt;パラメーターの多い関数なので手間はかかりますが、ミスのないように注意しながら1個1個指定します。&lt;/p&gt;

&lt;p&gt;注意点として、関数のパラメーターの順序を変更したり、新しいパラメーターを追加すると、ノードの接続情報も再設定する必要があります。&lt;/p&gt;

&lt;!--
UEのMaterialのノードの接続は番号（整数のインデックス）で接続情報を保持しているようなので、パラメーターの順序を入れ替えたり、途中にパラメーターを追加すると、ノード上の接続もやり直しになります。
--&gt;

&lt;p&gt;繰り返しになりますが、Include File Pathsは実際のファイルパスとは異なる点に留意して、&lt;code&gt;/Project/Raymarching.ush&lt;/code&gt;と指定してください。&lt;/p&gt;

&lt;h2 id=&#34;material全体のdetails&#34;&gt;Material全体のDetails&lt;/h2&gt;

&lt;p&gt;Material全体のDetailsは以下のように設定します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_graph_details_text.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_graph_details_text.png&#34; alt=&#34;Material全体のDetails&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Material Domain: Surface

&lt;ul&gt;
&lt;li&gt;レイマーチングはボリュームレダリングの印象があるかもしれませんが、Surfaceで問題ありません&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Blend Mode: Masked

&lt;ul&gt;
&lt;li&gt;レイマーチングの衝突判定によって形状をマスクする必要があります&lt;/li&gt;
&lt;li&gt;このオプションを有効にすることで、Opacity Maskを出力できます

&lt;ul&gt;
&lt;li&gt;交差している場合は1、交差していない場合は0を出力します&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Shading Model: Default Lit

&lt;ul&gt;
&lt;li&gt;ライティング計算はエンジン側に任せます&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Two Sideded: ON

&lt;ul&gt;
&lt;li&gt;カメラがレイマーチングの内部に入った場合に両面描画が必要です&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;materialノード解説-カメラのレイの生成&#34;&gt;Materialノード解説：カメラのレイの生成&lt;/h2&gt;

&lt;p&gt;ここからはノードの解説をします。まずはカメラのレイを生成するためのノードです。&lt;/p&gt;

&lt;p&gt;次のようなノードでカメラのレイを生成しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_camera.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_camera.png&#34; alt=&#34;Materialノード解説：カメラのレイの生成&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;レイは2つの3次元ベクトルで定義されます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;origin: レイの原点&lt;/li&gt;
&lt;li&gt;ray: レイの向き&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;rayの計算&#34;&gt;rayの計算&lt;/h3&gt;

&lt;p&gt;レイの方向（ray）はシンプルです。&lt;/p&gt;

&lt;p&gt;カメラの位置と、描画しようとしているSurfaceの座標（Absolute World Position）の差分（Subtract）から計算できます。&lt;/p&gt;

&lt;p&gt;最後にTransform Vectorノードでワールドスペースからローカルスペースに変換しています。&lt;/p&gt;

&lt;p&gt;今回はオブジェクトスペースのレイマーチングのため、レイマーチングのCustomノードに入力する位置や向きはすべてローカルスペースに変換する必要があります。&lt;/p&gt;

&lt;h3 id=&#34;originの計算&#34;&gt;originの計算&lt;/h3&gt;

&lt;p&gt;レイの原点（origin）の計算には分岐（DynamicBranch）があります。&lt;/p&gt;

&lt;p&gt;これはカメラがレイマーチングの空間の内部に潜った場合を考慮しているためです。&lt;/p&gt;

&lt;p&gt;カメラの位置によってoriginを分岐しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カメラが外部にある場合: origin = Absolute World Position&lt;/li&gt;
&lt;li&gt;カメラが内部にある場合: origin = カメラの位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また、originもローカルスペースにする必要があるため、Transform Positionノードで変換しています。&lt;/p&gt;

&lt;p&gt;カメラの内部/外部の判定はInsideCubeノードで行われています。これもCustomノードです。&lt;/p&gt;

&lt;p&gt;Codeには &lt;code&gt;isInsideCube(localPos)&lt;/code&gt; と指定しています。これは&lt;code&gt;Raymarching.ush&lt;/code&gt;で定義された関数です。&lt;/p&gt;

&lt;p&gt;この分岐によって、カメラがレイマーチングの外部にある場合でも内部にある場合でも、問題なく動作するようになっています。&lt;/p&gt;

&lt;p&gt;また、「Two Sideded: ON」にしている理由は、カメラがレイマーチングの内部に入っている場合において、Cubeの裏面側でレイマーチングを描画するためです。&lt;/p&gt;

&lt;p&gt;これによって、以下のGIFアニメーションでは、カメラがレイマーチングの空間の内部に入り込んだ場合でも正常に描画されています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/camera_inside_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/camera_inside_v1.gif&#34; alt=&#34;カメラがレイマーチングの空間の内部に潜った場合&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;materialノード解説-前後関係の解決-pixel-depth-offsetの計算&#34;&gt;Materialノード解説：前後関係の解決（Pixel Depth Offsetの計算）&lt;/h2&gt;

&lt;p&gt;他のオブジェクトと重なった場合でも、前後関係を正しく解決するための工夫について説明します。&lt;/p&gt;

&lt;p&gt;以下のGIFアニメーションのように、白い球体と重なっている場合でも、前後関係を正しく解決できています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_transform_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_transform_v1.gif&#34; alt=&#34;前後関係の解決: 平行移動&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_scale_v1.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/depth_scale_v1.gif&#34; alt=&#34;前後関係の解決: スケール&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;UEのMaterialではDepthBufferを直接書き込むことはできませんが、ワールド座標でのDepthの押し込み距離から、Pixel Depth Offsetを計算することで前後関係を解決しています。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_pixel_depth_offset.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2023-07-30-raymarching-in-ue5/material_pixel_depth_offset.png&#34; alt=&#34;Materialノード解説：前後関係の解決（Pixel Depth Offsetの計算）&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pixel Depth Offsetは、ワールド空間でのオフセット距離を計算する必要があります。したがって、Raymarchingの衝突点（hit）をTransform Positionノードを使用してワールド座標に変換し、Absolute World Positionとの差分（Subtract）を計算し、その距離（Length）を計算しています。&lt;/p&gt;

&lt;p&gt;Pixel Depth Offsetでは、カメラの奥方向にのみオフセットすることができます。逆に手前にオフセットさせることはできません。この制約は、パフォーマンスの向上を目的としています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/EGJ-Nori_Shinoyama/items/42cb29e95eca601250db&#34;&gt;[UE4] Pixel Depth Offsetは何故画面奥にしか行かないのかまた本当に重たいのかどうか問題 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;カメラがレイマーチングの内部にある場合、Cubeの裏面のSurfaceからは、衝突点（hit）が手前に来るため、Pixel Depth Offsetはマイナス値となります。
しかしこのマイナス値は利用できないため、カメラが内部にある場合は、&lt;code&gt;Pixel Depth Offset = 0&lt;/code&gt; となるようにLerpノードで分岐しています&lt;/p&gt;

&lt;!--
今回はLerpで分岐を処理しましたが、`Max(0, x)` でも良いと思います。
--&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;UE5.2でオブジェクトスペースのレイマーチングを実装できた

&lt;ul&gt;
&lt;li&gt;Actorに追従し、通常のMeshのようにギズモによりマウスで配置や変形ができる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;エンジンのレンダリング機能とも破綻なく統合できた

&lt;ul&gt;
&lt;li&gt;床への反射やグローバルイルミネーションに統合できた&lt;/li&gt;
&lt;li&gt;Opacity Mask、Pixel Depth Offsetを利用して、他のオブジェクトの前後関係なども解決できた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ノードとコードの役割分担をうまくできた

&lt;ul&gt;
&lt;li&gt;複雑な処理はHLSLによるコードで実装し、Customノードで呼び出す&lt;/li&gt;
&lt;li&gt;オブジェクトスペースのための座標変換はノードを利用することでシンプルに実装できた&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;UEの細かいTipsについては別記事でまとめる予定

&lt;ul&gt;
&lt;li&gt;「Ctrl + 1 + 左クリック」でスカラーの定数ノードを作成できる&lt;/li&gt;
&lt;li&gt;VS2022プロジェクトの作成に失敗する場合、Source Code Editorを再選択すると解決することがある&lt;/li&gt;
&lt;li&gt;UnityとUEの座標系やスケールの違いについて&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考資料&#34;&gt;参考資料&lt;/h2&gt;

&lt;p&gt;UE4やUnity上でのレイマーチング実装の前例を以下に紹介します。これらの情報をとても参考にさせていただきました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coposuke.hateblo.jp/entry/2019/12/11/002521&#34;&gt;【UE4】Object Space Raymarching (Material Editor) - コポうぇぶろぐ&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;UE4上でのレイマーチング実装の取り組み&lt;/li&gt;
&lt;li&gt;当時は Include File Paths が存在しなかったため、Customノードの関数定義に対するハックが必要であったことなどに触れています。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nanka.hateblo.jp/entry/2019/08/27/004905&#34;&gt;Unity HDRPのLitシェーダーを改造してレイマーチングする（GBuffer編） - なんかやる&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Unity HDRP上でのレイマーチング実装の取り組み&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>UnityのShaderGraphでインクシェーダーを作る</title>
      <link>https://gam0022.net/blog/2022/12/25/unity-ink-shader/</link>
      <pubDate>Sun, 25 Dec 2022 23:03:44 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2022/12/25/unity-ink-shader/</guid>
      <description>&lt;p&gt;これは&lt;a href=&#34;https://qiita.com/advent-calendar/2022/unity&#34;&gt;Unity Advent Calendar 2022&lt;/a&gt;の22日目の記事です。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;スプラトゥーン3、けっこう面白いですね。過去作の1,2は未プレイでしたが、3からスプラデビューしました。&lt;/p&gt;

&lt;p&gt;スプラ3で遊びながら、インクシェーダーの実装方法に興味が出てきたので、UnityのShaderGraphでそれっぽいものを実装してみました。&lt;/p&gt;

&lt;p&gt;ShaderGraphの基本機能だけで構成されており、ノードの量も少なめにしました。&lt;/p&gt;

&lt;p&gt;ShaderGraphの基本操作は解説しませんが、なるべく丁寧に説明をしたつもりなので、ShaderGraphの入門記事として参考にしてください！&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;UnityのShaderGraphでインクシェーダーを試作&lt;a href=&#34;https://twitter.com/hashtag/Unity3D?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Unity3D&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/ShaderGraph?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ShaderGraph&lt;/a&gt; &lt;a href=&#34;https://t.co/PHxIkfnkiQ&#34;&gt;pic.twitter.com/PHxIkfnkiQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1606141695724204032?ref_src=twsrc%5Etfw&#34;&gt;December 23, 2022&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/ink-shader.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/ink-shader.gif&#34; alt=&#34;インクシェーダー&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;色変更&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/ink-shader-color.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/ink-shader-color.gif&#34; alt=&#34;インクシェーダー 色変更&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;しきい値の調整&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/ink-shader-threshold.gif&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/ink-shader-threshold.gif&#34; alt=&#34;インクシェーダー しきい値の調整&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Unityプロジェクト

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/ShaderPlaygroundURP&#34;&gt;github.com/gam0022/ShaderPlaygroundURP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gam0022.net/ShaderPlaygroundURP/&#34;&gt;WebGLデモ&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;WASDと右クリックのドラッグでカメラ操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;shadergraph全体&#34;&gt;ShaderGraph全体&lt;/h1&gt;

&lt;p&gt;ShaderGraphの全体です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/InkNoise.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/InkNoise.png&#34; alt=&#34;ShaderGraph全体&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ShaderGraphのスクロール領域を含めてキャプチャするために &lt;a href=&#34;https://github.com/Cyanilux/ShaderGraphToPNG&#34;&gt;Cyanilux/ShaderGraphToPNG&lt;/a&gt; というUnityのパッケージを利用しました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;完璧なソリューションがありました。&lt;br&gt;Unity2021.3.15f1 + URP12.1.8 でも完璧に動作！&lt;a href=&#34;https://t.co/3J2qsrye8s&#34;&gt;https://t.co/3J2qsrye8s&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1607359807710978049?ref_src=twsrc%5Etfw&#34;&gt;December 26, 2022&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;!--
文字が小さくてすみません。

※2回に分けてスクリーンショットを撮影してMSペイントで手動結合しました。3回以上分割して撮影すればもっと高解像度にできるのですが、手間がかかるので諦めました。
いい感じにウィンドウのスクロール領域を含めて一発でスクリーンショットを撮る方法があれば教えてください。

[![ShaderGraph全体](/images/posts/2022-12-26-unity-ink-shader/shader-graph-all.png)](/images/posts/2022-12-26-unity-ink-shader/shader-graph-all.png)
--&gt;

&lt;h2 id=&#34;基本方針&#34;&gt;基本方針&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;URPのLitグラフに与えるBaseColorやSmoothnessや法線をいい感じに制御してインクっぽくする

&lt;ul&gt;
&lt;li&gt;カスタムなシェーディングはしない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;インクの高さマップはGradient Noiseからプロシージャル生成

&lt;ul&gt;
&lt;li&gt;インタラクティブなインク制御は未対応&lt;/li&gt;
&lt;li&gt;RenderTextureを生成してペイントするようなアプローチでインタラクティブにできそう（今後の課題）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;チュートリアル&#34;&gt;チュートリアル&lt;/h1&gt;

&lt;p&gt;そこまで規模の大きくないShaderGraphですが、理解しやすいように1ステップごと解説します。&lt;/p&gt;

&lt;h2 id=&#34;ステップ1-pbrテクスチャに対応&#34;&gt;ステップ1. PBRテクスチャに対応&lt;/h2&gt;

&lt;p&gt;まずはPBRテクスチャに対応します。&lt;/p&gt;

&lt;p&gt;PBRテクスチャは以下のサイトからお借りしました。とても良い感じのCC0ライセンスの床のタイル素材を利用させていただきました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://polyhaven.com/a/cobblestone_floor_08&#34;&gt;Cobblestone Floor 08 Texture • Poly Haven&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これがPBRテクスチャをプロパティにして、ShaderGraphの各種PBRパラメーターを渡すだけのShaderGraphです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/1-armtex.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/1-armtex.png&#34; alt=&#34;PBRテクスチャに対応&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;BaseColor&lt;/code&gt; や &lt;code&gt;Normal&lt;/code&gt; はそのままノードを繋げるだけでOKです。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Metallic/Smoothness/Ambient Occlusion&lt;/code&gt; だけ少し工夫がいります。&lt;/p&gt;

&lt;p&gt;Poly Havenのテクスチャは &lt;code&gt;Ambient Occlusion/Roughness/Metallic&lt;/code&gt;（以下、ARMテクスチャ）がRGBに格納されているようなので、RGBの順番をBGRのように並び替える必要があります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Smoothness = 1 - Roughness&lt;/code&gt; の関係があるので &lt;code&gt;One Minus&lt;/code&gt; ノードで変換します。&lt;/p&gt;

&lt;p&gt;これでPoly Havenから落としてきたARMテクスチャに対応したShaderGraphができました。&lt;/p&gt;

&lt;h2 id=&#34;ステップ2-uvのタイリング&#34;&gt;ステップ2. UVのタイリング&lt;/h2&gt;

&lt;p&gt;ここから最終的なインクシェーダーのShaderGraphをステップごとに解説します。&lt;/p&gt;

&lt;p&gt;まずUVのタイリングですが、単純にUVに定数を乗算しているだけです。今回は下地のテクスチャ用とインク用で独立してタイリングできるようにしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/2-uv.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/2-uv.png&#34; alt=&#34;UVのタイリング&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ステップ3-インクの高さマップ用のノイズ生成&#34;&gt;ステップ3. インクの高さマップ用のノイズ生成&lt;/h2&gt;

&lt;p&gt;インクの高さマップはGradient Noiseから生成します。時間でアニメーションさせるために2つのGradient Noiseを線形補間で合成しています。&lt;/p&gt;

&lt;p&gt;1つ目のGradient NoiseのUVは固定させておいて、2つ目のGradient NoiseのUVはtimeでスクロールさせています。&lt;/p&gt;

&lt;p&gt;非常にシンプルな処理ですが、意外にもそれなりにインクっぽく見えるのではないでしょうか？&lt;/p&gt;

&lt;p&gt;余談になりますが、ShaderGraphのGradient Noiseはシェーダーでプロシージャル生成しているのでGPU負荷も高いと思います。実用するなら軽量化のためにテクスチャのサンプリングに置き換えた方がいいかもしれません。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/3-noise.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/3-noise.png&#34; alt=&#34;インクの高さマップ用のノイズ生成&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ステップ4-凹凸を考慮したインク判定のしきい値&#34;&gt;ステップ4. 凹凸を考慮したインク判定のしきい値&lt;/h2&gt;

&lt;p&gt;ステップ3. でインクの高さマップを生成しました。この高さマップがしきい値以上ならインクの領域と見なすようにします。&lt;/p&gt;

&lt;p&gt;インク判定のしきい値は定数でも良いのですが、高さマップを考慮してブロックの溝など低い部分の方がインクになりやすくします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/4-threshold.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/4-threshold.png&#34; alt=&#34;インクの高さマップ用のノイズ生成&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;高さマップの影響力はプロパティで制御できるようにしました。&lt;/p&gt;

&lt;p&gt;高さマップの考慮がないと真っ平らなPlaneにインクが乗っているようで、雑コラ感・馴染まない感があります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/height-intensity-off.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/height-intensity-off.png&#34; alt=&#34;高さマップの考慮なし&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;高さマップを考慮すると、ブロックの凹凸を考慮してインクが広がるので、リアリティを少し向上できます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/height-intensity-on.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/height-intensity-on.png&#34; alt=&#34;高さマップの考慮あり&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ステップ5-インクのマスク生成&#34;&gt;ステップ5. インクのマスク生成&lt;/h2&gt;

&lt;p&gt;「ステップ3のインクの高さマップ」から「ステップ4のしきい値」を引き算することで、インクのマスク画像を生成します。&lt;/p&gt;

&lt;p&gt;そのままだとコントラストが薄いので、Powerノードでコントラストを強めに調整します。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/5-1-ink-mask.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/5-1-ink-mask.png&#34; alt=&#34;インクのマスク生成&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;インクのマスクマップをLerpの引数にして、各種PBRパラメーターにインク用の値をブレンドします。
元はARMテクスチャの値をそのままPBRパラメーターとして渡していましたが、間にLerpノードを挟み込んで、インク用の &lt;code&gt;Ambient Occlusion/Roughness/Metallic&lt;/code&gt; をブレンドできるようにしました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/5-2-ink-mask.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/5-2-ink-mask.png&#34; alt=&#34;インク用の設定をブレンド&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;BaseMapも同じようにLerpします。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/5-3-ink-mask.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/5-3-ink-mask.png&#34; alt=&#34;インク用の設定をブレンド(BaseMap)&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ステップ6-法線の生成&#34;&gt;ステップ6. 法線の生成&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/6-normal.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-12-26-unity-ink-shader/6-normal.png&#34; alt=&#34;法線の生成&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ステップ3のインクの高さマップから法線を生成します。Normal From Heightノードがあるので利用します。&lt;/p&gt;

&lt;p&gt;ステップ5のインクのマスクでは高さマップの影響で高周波成分が現れてしまうので滑らかな法線ができず、法線生成には不適切です。しきい値を引き算する前のGradient Noiseの値をNormal From Heightノードに繋ぎます。&lt;/p&gt;

&lt;p&gt;今回もPowerノードでコントラストを調整可能にしました。SaturateノードではなくMaximumノードを利用しているのでは、 &lt;code&gt;Clamp(x, 0, INF)&lt;/code&gt; にしたいからです。&lt;/p&gt;

&lt;p&gt;マスク画像の結果は &lt;code&gt;[0-1]&lt;/code&gt; に正規化する必要がありますが、法線生成のHeightマップであれば最大値の制限は不要だと思ったからです。&lt;/p&gt;

&lt;p&gt;以上がインク用のシェーダーの解説でした。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;ShaderGraphだけでノーコードのインクシェーダーを試作しました。
PBRパラメーターを制御するだけのお手軽な実装ですが、思ったよりも良い見た目になったので満足です。&lt;/p&gt;

&lt;p&gt;今回はインクのマスクにGradient Noiseを利用しましたが、RenderTextureをシェーダー外部から与えればインタラクティブにインクを塗ったりもできると思います。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>normalize.fmにゲスト出演しました</title>
      <link>https://gam0022.net/blog/2022/10/20/normalizefm/</link>
      <pubDate>Thu, 20 Oct 2022 10:44:48 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2022/10/20/normalizefm/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://normalize.fm/&#34;&gt;normalize.fm&lt;/a&gt;の第032回にゲスト出演させていただきました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/hashtag/normalizeFM?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#normalizeFM&lt;/a&gt; の新エピソード公開しました。&lt;br&gt;今回は &lt;a href=&#34;https://twitter.com/gam0022?ref_src=twsrc%5Etfw&#34;&gt;@gam0022&lt;/a&gt; さんをゲストに、普段の収録と比較するとかなりテックな話題に寄った感じで、深い技術の話をいろいろうかがいました。&lt;br&gt;&lt;br&gt;032. たゆまぬ努力とキャッチアップ&lt;a href=&#34;https://t.co/acML0WOwYQ&#34;&gt;https://t.co/acML0WOwYQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; h_doxas (@h_doxas) &lt;a href=&#34;https://twitter.com/h_doxas/status/1582287588978618369?ref_src=twsrc%5Etfw&#34;&gt;October 18, 2022&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>KodeLifeでMIDIコンを使うのがとても簡単だった</title>
      <link>https://gam0022.net/blog/2022/05/08/kodelife-midi/</link>
      <pubDate>Sun, 08 May 2022 21:56:23 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2022/05/08/kodelife-midi/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://hexler.net/kodelife&#34;&gt;KodeLife&lt;/a&gt;でMIDIコンを使うのがとても簡単でした。こんな感じにVJっぽいことが気軽にできます。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ht&#34; dir=&#34;ltr&#34;&gt;KORG nanoKONTROL2 + KodeLife &lt;a href=&#34;https://t.co/UqFQqYUFHa&#34;&gt;pic.twitter.com/UqFQqYUFHa&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1487783819730059264?ref_src=twsrc%5Etfw&#34;&gt;January 30, 2022&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;このシェーダーは&lt;a href=&#34;https://gam0022.net/blog/2021/12/31/tdf2021-shader-showdown/&#34;&gt;Tokyo Demo Fest 2021のShader Showdown&lt;/a&gt;をKodeLife向けに少し修正したものです。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;kodelifeとは&#34;&gt;KodeLifeとは&lt;/h1&gt;

&lt;p&gt;リアルタイムにシェーダーのライブコーディングをするためのソフトです。&lt;/p&gt;

&lt;p&gt;Mac / Windows / Linux / iOS / Androidなど幅広いプラットフォームに対応しています。&lt;/p&gt;

&lt;h1 id=&#34;kodelifeでmidiコンを使うまでの手順&#34;&gt;KodeLifeでMIDIコンを使うまでの手順&lt;/h1&gt;

&lt;p&gt;公式マニュアルの&lt;a href=&#34;https://hexler.net/kodelife/manual/parameters-built-in&#34;&gt;Parameters · Built-In&lt;/a&gt;を見れば解決なのですが、KodeLifeまったく使ったことのない人向けに画像付きで手順をまとめました。&lt;/p&gt;

&lt;h2 id=&#34;1-新規プロジェクトを作成&#34;&gt;1. 新規プロジェクトを作成&lt;/h2&gt;

&lt;p&gt;まずはKodeLifeを起動して新規プロジェクトを作成します。&lt;/p&gt;

&lt;h2 id=&#34;2-midi-channelを追加&#34;&gt;2. MIDI Channelを追加&lt;/h2&gt;

&lt;p&gt;MIDIコントローラーの入力を受けるけるために、パラメーターのリストにMIDI Channelを追加します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Project &amp;gt; Parameters &amp;gt; ＋ボタン &amp;gt; Built-in &amp;gt; Input &amp;gt; MIDI Channel&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-05-08-kodelife-midi/add-midi-channel.png&#34; alt=&#34;MIDI Channelを追加&#34; /&gt;&lt;/p&gt;

&lt;p&gt;追加するとこうなります。MIDI Channelの設定はデフォルトのままでOKです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2022-05-08-kodelife-midi/midi-channel.png&#34; alt=&#34;MIDI Channelの設定&#34; /&gt;&lt;/p&gt;

&lt;p&gt;デフォルトの状態だとMIDIの入力が32x32のテクスチャとしてサンプリング可能になります。&lt;/p&gt;

&lt;h2 id=&#34;3-midi-channelをシェーダーからサンプリング&#34;&gt;3. MIDI Channelをシェーダーからサンプリング&lt;/h2&gt;

&lt;h3 id=&#34;midi入力を受け取るmidi関数を定義&#34;&gt;midi入力を受け取るmidi関数を定義&lt;/h3&gt;

&lt;p&gt;前述のとおり、MIDIの入力が32x32のテクスチャとしてサンプリング可能になります。&lt;/p&gt;

&lt;p&gt;まずテクスチャのサンプラーを定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;uniform sampler2D midi1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、こんな感じのmidi関数を定義します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ivec2 midiCoord(int offset)
{
    int x = offset % 32;
    int y = offset / 32;
    return ivec2(x, y);
}

float midi(int ccNumber) {
    return texture(midi1, vec2((1. / 32.) * midiCoord(3 * 127 + ccNumber))).r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;midi関数の使用例&#34;&gt;midi関数の使用例&lt;/h3&gt;

&lt;p&gt;midi関数は&lt;a href=&#34;https://www.g200kg.com/jp/docs/dic/controlchange.html&#34;&gt;コントロールチェンジ番号&lt;/a&gt;を受け取って、対応する値を [0-1] の範囲で返します。テクスチャなので [0-1] です。&lt;/p&gt;

&lt;p&gt;IFSのイテレーションなどにmidi関数を使えば、冒頭の動画のようにIFSの幾何学形状をMIDIコンで制御できます！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;vec4 map(vec3 p) {
    vec3 pos = p;
    p = mod(p, 1.) - 0.5;
    vec4 m = vec4(1, 1, 1, 1);

    float s = 1.;
    for (int i = 0; i &amp;lt; 10 * midi(0); i++) {// MIDIコンでIFSのイテレーションを制御
        p = abs(p) - 0.5;
        rot(p.xy, -0.5);
        p = abs(p) - 0.4;
        rot(p.yz, -0.1);

        float a = 1.0 + midi(1);// MIDIコンでIFSのスケールを制御
        p *= a;
        s *= a;
    }

    U(m, sdBox(p, vec3(0.5, 0.05, 0.05)) / s, 1., 1., 0.);
    U(m, sdBox(p, vec3(0.5 + 0.5 * (cos(TAU * time * 0 / 4.)), 0.06, 0.05)) / s, 0., 0.1, 0.5);
    U(m, sdBox(p, vec3(0.2, 0.6, 0.1)) / s, 0., saturate(cos(TAU * (time + pos.z / 8.))), -0.5);

    return m;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シェーダーの全文は&lt;a href=&#34;https://gist.github.com/gam0022/23fc2128753495f88b6824e1dd134168&#34;&gt;gist&lt;/a&gt;にあります。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;KodeLifeではMIDIコンを簡単に使えて素敵！という小ネタでした。&lt;/p&gt;

&lt;p&gt;ちなみに使ったMIDIコンは&lt;a href=&#34;https://amzn.to/39LN12C&#34;&gt;KORG nanoKONTROL2&lt;/a&gt;です。&lt;/p&gt;

&lt;iframe sandbox=&#34;allow-popups allow-scripts allow-modals allow-forms allow-same-origin&#34; style=&#34;width:120px;height:240px;&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; frameborder=&#34;0&#34; src=&#34;//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=gam00220c-22&amp;language=ja_JP&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=as_ss_li_til&amp;asins=B004M8UZS8&amp;linkId=8165ff008f7ff356a2d6382883941aca&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;せっかくMIDIコンを買ったのに、とくにVJする機会もないので置物になってます。誰かVJに誘ってください。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Unity][URP] Y軸ビルボードシェーダー</title>
      <link>https://gam0022.net/blog/2021/12/23/unity-urp-billboard-shader/</link>
      <pubDate>Thu, 23 Dec 2021 10:00:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2021/12/23/unity-urp-billboard-shader/</guid>
      <description>&lt;p&gt;これは&lt;a href=&#34;https://qiita.com/advent-calendar/2021/unity&#34;&gt;Unity Advent Calendar 2021&lt;/a&gt;の23日目の記事です。&lt;/p&gt;

&lt;p&gt;前日は&lt;a href=&#34;https://twitter.com/UnagiHuman&#34;&gt;@UnagiHuman&lt;/a&gt;さんの&lt;a href=&#34;https://qiita.com/UnagiHuman/items/7db6c75adea0d5862acf&#34;&gt;「Unityの新MeshAPIでMeshColliderをリアルタイム変形させる」&lt;/a&gt;でした。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;こんな感じのY軸のビルボードをC#スクリプトを使わずに、シェーダーだけで実装しました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-12-23-unity-urp-billboard-shader/Unity-URP-Billboard-trim.gif&#34; alt=&#34;Y軸ビルボード&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GitHubリポジトリ: &lt;a href=&#34;https://github.com/gam0022/unity-urp-shader&#34;&gt;gam0022/unity-urp-shader&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;要約&#34;&gt;要約&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;シェーダーだけでY軸ビルボードを実装&lt;/li&gt;
&lt;li&gt;UnityのURP対応&lt;/li&gt;
&lt;li&gt;回転行列を生成するアプローチなので、プラットフォーム間の違い（Zの方向やUVの上下など）による問題が起きない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;シェーダーで実装するメリット&#34;&gt;シェーダーで実装するメリット&lt;/h1&gt;

&lt;p&gt;シェーダーでビルボードを計算するメリットはたくさんあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C#スクリプトが不要でシェーダーだけで動作する

&lt;ul&gt;
&lt;li&gt;シェーダーのポータビリティは高い&lt;/li&gt;
&lt;li&gt;昔のVRCのようにユーザスクリプトが書けない環境でも使える&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;シーンビュー上でも動作する&lt;/li&gt;
&lt;li&gt;GPU（頂点シェーダー）でビルボード計算ができる

&lt;ul&gt;
&lt;li&gt;ビルボード計算のためのCPU負荷は0&lt;/li&gt;
&lt;li&gt;板ポリの頂点数は4なので、頂点シェーダーでビルボード処理をしても、GPU負荷はかなり軽い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;シェーダーのコード-全体&#34;&gt;シェーダーのコード（全体）&lt;/h1&gt;

&lt;p&gt;最終的なシェーダーのコードはこちらです。&lt;/p&gt;

&lt;p&gt;単体で動作するので、コピペして使えます。&lt;a href=&#34;https://github.com/gam0022/unity-urp-shader/blob/master/LICENSE&#34;&gt;MITライセンス&lt;/a&gt;です。&lt;/p&gt;

&lt;p&gt;ファイル名: &lt;a href=&#34;https://github.com/gam0022/unity-urp-shader/blob/master/Assets/URP-Shaders/Billboard/Shaders/Unlit-Billboard.shader&#34;&gt;&lt;code&gt;Unlit-Billboard.shader&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// URP-Unlit-Billboard Shader by @gam0022 (MIT Licence)
// https://gam0022.net//blog/2021/12/23/unity-urp-billboard-shader/
Shader &amp;quot;Universal Render Pipeline/Unlit-Billboard&amp;quot;
{
    Properties
    {
        _BaseMap (&amp;quot;Base Map&amp;quot;, 2D) = &amp;quot;white&amp;quot; { }
        _BaseColor (&amp;quot;Base Color&amp;quot;, Color) = (1, 1, 1, 1)
        _Cutoff (&amp;quot;Alpha Cutoff&amp;quot;, Range(0, 1)) = 0.5
    }

    SubShader
    {
        Tags {
            &amp;quot;RenderPipeline&amp;quot; = &amp;quot;UniversalPipeline&amp;quot;
            &amp;quot;RenderType&amp;quot; = &amp;quot;TransparentCutout&amp;quot;
            &amp;quot;Queue&amp;quot; = &amp;quot;AlphaTest&amp;quot;
            &amp;quot;IgnoreProjector&amp;quot; = &amp;quot;True&amp;quot;
        }

        Pass
        {
            Tags { &amp;quot;LightMode&amp;quot; = &amp;quot;UniversalForward&amp;quot; }

            HLSLPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include &amp;quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&amp;quot;

            struct Attributes
            {
                float4 positionOS: POSITION;
                float2 uv: TEXCOORD0;
            };

            struct Varyings
            {
                float4 positionHCS: SV_POSITION;
                float2 uv: TEXCOORD0;
            };

            sampler2D _BaseMap;

            CBUFFER_START(UnityPerMaterial)
            float4 _BaseMap_ST;
            half4 _BaseColor;
            half _Cutoff;
            CBUFFER_END

            Varyings vert(Attributes IN)
            {
                Varyings OUT;

                // 回転行列を生成してビルボード処理をします
                float3 yup = float3(0.0, 1.0, 0.0);
                float3 up = mul((float3x3)unity_ObjectToWorld, yup);

                float3 worldPos = unity_ObjectToWorld._m03_m13_m23;
                float3 toCamera = _WorldSpaceCameraPos - worldPos;
                float3 right = normalize(cross(toCamera, up)) * length(unity_ObjectToWorld._m00_m10_m20);
                float3 forward = normalize(cross(up, right)) * length(unity_ObjectToWorld._m02_m12_m22);

                float4x4 mat = {
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1,
                };
                mat._m00_m10_m20 = right;
                mat._m01_m11_m21 = up;
                mat._m02_m12_m22 = forward;
                mat._m03_m13_m23 = worldPos;

                float4 vertex = float4(IN.positionOS.xyz, 1);
                vertex = mul(mat, vertex);
                OUT.positionHCS = mul(UNITY_MATRIX_VP, vertex);

                OUT.uv = TRANSFORM_TEX(IN.uv, _BaseMap);
                return OUT;
            }

            half4 frag(Varyings IN): SV_Target
            {
                half4 base = tex2D(_BaseMap, IN.uv);
                clip(base.a - _Cutoff);
                return base * _BaseColor;
            }
            ENDHLSL

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;解説&#34;&gt;解説&lt;/h1&gt;

&lt;h2 id=&#34;前回の記事との違い&#34;&gt;前回の記事との違い&lt;/h2&gt;

&lt;p&gt;この記事は前回の記事&lt;a href=&#34;https://gam0022.net/blog/2019/07/23/unity-y-axis-billboard-shader/&#34;&gt;[Unity] Y軸ビルボードシェーダーの実装と解説&lt;/a&gt;の改訂版です。以下のような違いがあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;URP（Universal Render Pipeline）に対応&lt;/li&gt;
&lt;li&gt;ビルボード処理のアプローチを改良（プラットフォーム依存をなくす）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;前回の記事-ビュー変換をスキップ-の欠点&#34;&gt;前回の記事（ビュー変換をスキップ）の欠点&lt;/h3&gt;

&lt;p&gt;前回の記事では、カメラのビュー行列の変換をスキップすることで、ビルボード処理を実装していました。&lt;/p&gt;

&lt;p&gt;Unityではプラットフォーム間の違い（Zの方向やUVの上下など）をビュー行列とプロジェクション行列でうまく吸収する設計になっており、ビュー行列の変換をスキップするとプラットフォームの対応を自力で行う必要が出てきて、かなり面倒でした。
将来的に新しいプラットフォームが増えた時などにシェーダーの修正が必要になる可能性もあり、このアプローチは筋が良くないな、と記事の公開後に思っていました。&lt;/p&gt;

&lt;p&gt;今回紹介する &lt;strong&gt;回転行列を生成するアプローチ&lt;/strong&gt; では、そのようなプラットフォーム依存の問題が起きません。&lt;/p&gt;

&lt;h2 id=&#34;回転行列を生成するアプローチ&#34;&gt;回転行列を生成するアプローチ&lt;/h2&gt;

&lt;p&gt;Unityが生成するモデル行列を使わずに、頂点シェーダーの中でうまく回転行列を生成することで、常にカメラ側を向くようにMeshを回転させてビルボード処理を実現します。&lt;/p&gt;

&lt;p&gt;シェーダーからビルボード処理を抜き出して、できるだけコメントを入れました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 回転行列を生成してビルボード処理をします
// 常にカメラ側を向くようにMeshを回転させます

// Y-UPベクトル
float3 yup = float3(0.0, 1.0, 0.0);

// up = Y軸の基底ベクトル
// オブジェクトのTransformの回転を考慮
float3 up = mul((float3x3)unity_ObjectToWorld, yup);

// オブジェクトのワールド座標
float3 worldPos = unity_ObjectToWorld._m03_m13_m23;

// オブジェクトからカメラに向かうベクトル
float3 toCamera = _WorldSpaceCameraPos - worldPos;

// right = X軸の基底ベクトル
// 前半の項 : rightはtoCameraとupの両方に直交するので、crossから計算
// 後半の項 : オブジェクトのTransformのX方向のスケールを考慮
float3 right = normalize(cross(toCamera, up)) * length(unity_ObjectToWorld._m00_m10_m20);

// forward = Z軸の基底ベクトル
// 前半の項 : forwardはupとrightの両方に直交するので、crossから計算
// 後半の項 : オブジェクトのTransformのZ方向のスケールを考慮
float3 forward = normalize(cross(up, right)) * length(unity_ObjectToWorld._m02_m12_m22);

// 各基底ベクトルを並べてビルボード用の回転行列を生成
// （厳密には平行移動とスケールも含んだ変換行列）
float4x4 mat = {
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1,
};
mat._m00_m10_m20 = right;//     X軸の基底ベクトル
mat._m01_m11_m21 = up;//        Y軸の基底ベクトル
mat._m02_m12_m22 = forward;//   Z軸の基底ベクトル
mat._m03_m13_m23 = worldPos;//  平行移動のベクトル


// ローカル座標（平行移動のためにw=1）
float4 vertex = float4(IN.positionOS.xyz, 1);

// ビルボード用の回転行列を乗算してワールド空間に変換
vertex = mul(mat, vertex);

// ビュー行列とプロジェクション行列を乗算してクリップ空間に変換
OUT.positionHCS = mul(UNITY_MATRIX_VP, vertex);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは超重要情報ですが、 &lt;strong&gt;回転後の空間の基底ベクトルを並べた行列が回転行列になります。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;これだけ覚えておけば、回転だけでなく、拡大縮小やSkew（せん断）の行列は自然に導出できます。&lt;/p&gt;

&lt;p&gt;知らなかった人はぜひ覚えておきましょう。CEDECで同じ話を2回くらいしています（&lt;a href=&#34;https://www.klab.com/jp/blog/creative/2020/cedec2020.html&#34;&gt;2020&lt;/a&gt;と&lt;a href=&#34;https://www.klab.com/jp/blog/tech/2021/cedec-kyushu-2021-online-3d.html&#34;&gt;2021&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-12-23-unity-urp-billboard-shader/kec2-1.png&#34; alt=&#34;基底ベクトルをイメージすればOK&#34; /&gt;
&lt;img src=&#34;https://gam0022.net/images/posts/2021-12-23-unity-urp-billboard-shader/kec2-2.png&#34; alt=&#34;回転ベクトル1&#34; /&gt;
&lt;img src=&#34;https://gam0022.net/images/posts/2021-12-23-unity-urp-billboard-shader/kec2-3.png&#34; alt=&#34;回転ベクトル2&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;スケール対応&#34;&gt;スケール対応&lt;/h2&gt;

&lt;p&gt;モデル行列 &lt;code&gt;unity_ObjectToWorld&lt;/code&gt; から各軸のスケールを取得することで、スケール対応ができます。
Y軸に関しては、upを計算するときにnormalizeしなければ自動でスケールが考慮されます。&lt;/p&gt;

&lt;h3 id=&#34;スケール対応なし&#34;&gt;スケール対応なし&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// up = Y軸の基底ベクトル
// オブジェクトのTransformの回転を考慮
float3 up = normalize(mul((float3x3)unity_ObjectToWorld, yup));

//...

// right = X軸の基底ベクトル
// rightはtoCameraとupの両方に直交するので、crossから計算
float3 right = normalize(cross(toCamera, up));

// forward = Z軸の基底ベクトル
// forwardはupとrightの両方に直交するので、crossから計算
float3 forward = normalize(cross(up, right));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;スケール対応あり&#34;&gt;スケール対応あり&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// up = Y軸の基底ベクトル
// オブジェクトのTransformの回転を考慮
float3 up = mul((float3x3)unity_ObjectToWorld, yup);

//...

// right = X軸の基底ベクトル
// 前半の項 : rightはtoCameraとupの両方に直交するので、crossから計算
// 後半の項 : オブジェクトのTransformのX方向のスケールを考慮
float3 right = normalize(cross(toCamera, up)) * length(unity_ObjectToWorld._m00_m10_m20);

// forward = Z軸の基底ベクトル
// 前半の項 : forwardはupとrightの両方に直交するので、crossから計算
// 後半の項 : オブジェクトのTransformのZ方向のスケールを考慮
float3 forward = normalize(cross(up, right)) * length(unity_ObjectToWorld._m02_m12_m22);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;追記&lt;br&gt;GameObjectのスケールに対応しました。&lt;a href=&#34;https://twitter.com/hashtag/Unity3d?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Unity3d&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/Shader?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Shader&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/HLSL?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#HLSL&lt;/a&gt; &lt;a href=&#34;https://t.co/gI4a3zpmJQ&#34;&gt;pic.twitter.com/gI4a3zpmJQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1473858972558200843?ref_src=twsrc%5Etfw&#34;&gt;December 23, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&#34;srp-batcher&#34;&gt;SRP Batcher&lt;/h2&gt;

&lt;p&gt;URP（SRP）からSRP Batcherというドローコールバッチング（厳密にはドローコールの数を減らすわけではなく、ドローコール間のGPUの設定コストを削減）の仕組みが導入されました。&lt;/p&gt;

&lt;p&gt;以前のビルドインレンダーパイプラインのドローコールバッチングではMeshが結合されるので、ビルボードのように特殊な頂点変換をするシェーダーでは考慮が必要で、けっこう面倒でした。&lt;/p&gt;

&lt;p&gt;SRP BatcherはMeshを結合しないので、頂点変換で特別な考慮をしなくてもシェーダーが動くようになりました！めでたい🎉&lt;/p&gt;

&lt;p&gt;今回のシェーダーをフレームデバッガーで確認すると、ちゃんとSRP Batcherで描画されているのが分かります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-12-23-unity-urp-billboard-shader/frame-debugger.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-12-23-unity-urp-billboard-shader/frame-debugger.png&#34; alt=&#34;SRP Batcher&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SRP Batcherについては、以下の記事が詳しいです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.unity.com/ja/technology/srp-batcher-speed-up-your-rendering&#34;&gt;SRP Batcher：レンダリングをスピードアップ | Unity Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;リンク&#34;&gt;リンク&lt;/h1&gt;

&lt;p&gt;参考にさせていただきました。ありがとうございます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;URP対応（SRP Batcherも対応👍）

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://light11.hatenadiary.com/entry/2021/07/29/194213&#34;&gt;【Unity】URP用のシェーダの書き方が旧パイプラインと微妙に違ってややこしいのでまとめた - LIGHT11&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;利用したテクスチャ素材

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pngall.com/tree-png/download/23754&#34;&gt;Tree PNG Clipart Background&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.deviantart.com/fabooguy/art/Dirt-Ground-Texture-Tileable-2048x2048-441212191&#34;&gt;Dirt/Ground Texture [Tileable | 2048x2048]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>『Unityゲーム プログラミング・バイブル 2nd Generation』のレイマーチングとTimelineの章を執筆しました</title>
      <link>https://gam0022.net/blog/2021/06/08/unity-bible2/</link>
      <pubDate>Tue, 08 Jun 2021 10:30:19 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2021/06/08/unity-bible2/</guid>
      <description>&lt;p&gt;6/29発売の&lt;a href=&#34;https://amzn.to/3oe2agf&#34;&gt;『Unityゲーム プログラミング・バイブル 2nd Generation』&lt;/a&gt;を執筆しました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/Collage_Fotor.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/Collage_Fotor.jpg&#34; alt=&#34;『Unityゲーム プログラミング・バイブル 2nd Generation』&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;『Unityゲーム プログラミング・バイブル 2nd Generation』について、公式ページから紹介文を引用します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Unityのゲーム開発現場で最も使われた決定版書籍が、大幅バージョンアップして登場!&lt;/strong&gt;
&lt;strong&gt;ゲームの開発現場で即実践できるスキルが身につく!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本書は、ゲーム開発で最も使われている「Unity」の入門や初級レベルを卒業した方向けの書籍です。ゲームの開発現場で、即実践できるスキルが身につくように、&lt;strong&gt;「37」の最新のトピックを網羅&lt;/strong&gt;しました。&lt;/p&gt;

&lt;p&gt;本書には、第一線の現場で活躍している23名の著者陣が参加しており、ゲーム開発のノウハウやTipsが満載されています。またほとんどのトピックでは、サンプルゲームがダウンロードでき、実際に動かしながら、実践的に学んでいくことが可能です。&lt;/p&gt;

&lt;p&gt;Unityでのゲーム開発のさまざまな場面で、すぐに役立つ1冊となっています。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--
![Unityゲーム プログラミング・バイブル 2nd Generation](/images/posts/2021-05-27-unity-bible2/Collage_Fotor.jpg)
--&gt;

&lt;p&gt;37のトピックのうち、私は次の2つを担当しました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;レイマーチング：基礎から応用まで&lt;/li&gt;
&lt;li&gt;Timelineによる映像制作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この記事では私の担当した内容を簡単に紹介します。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;『Unityゲーム プログラミング・バイブル 2nd Generation 』を執筆しました！&lt;br&gt;6/29発売です！&lt;br&gt;&lt;br&gt;・レイマーチング：基礎から応用まで&lt;br&gt;・Timelineによる映像制作&lt;br&gt;&lt;br&gt;の2本を担当しました。&lt;a href=&#34;https://t.co/lYWIxseCON&#34;&gt;https://t.co/lYWIxseCON&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1392725305526161411?ref_src=twsrc%5Etfw&#34;&gt;May 13, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;レイマーチング-基礎から応用まで&#34;&gt;レイマーチング：基礎から応用まで&lt;/h1&gt;

&lt;div style=&#34;display: flex;&#34;&gt;
    &lt;div style=&#34;width: 50%;&#34;&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/11_RaymarchingOpRepeat.jpg&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/11_RaymarchingOpRepeat.jpg&#34; alt=&#34;サンプル11 距離関数の応用：無限複製編&#34; /&gt;&lt;/a&gt;&lt;/div&gt;
    &lt;div style=&#34;width: 50%;&#34;&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/13_RaymarchingBoolean2.jpg&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/13_RaymarchingBoolean2.jpg&#34; alt=&#34;サンプル13 距離関数の応用：無限複製とブーリアン演算の合せ技&#34; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;!--
![サンプル11 距離関数の応用：無限複製編](/images/posts/2021-05-27-unity-bible2/11_RaymarchingOpRepeat.jpg)
![サンプル13 距離関数の応用：無限複製とブーリアン演算の合せ技](/images/posts/2021-05-27-unity-bible2/13_RaymarchingBoolean2.jpg)
--&gt;

&lt;p&gt;このセクションでは「レイマーチング」という手法により、グラフィックスを描画する仕組みを紹介しました。&lt;/p&gt;

&lt;p&gt;レイマーチングと似た名前の手法にレイトレーシングがありますが、どちらもレイ、つまり光線をプログラムでシミュレーションしてカメラに映る画像を生成する手法です。&lt;/p&gt;

&lt;p&gt;レイマーチングでは、距離関数という数式で定義した形状に対して、レイとの交差判定を行うことで照明や反射などの計算を行います。
そのため、通常のUnityの描画パイプラインではできないような表現が可能になるということが特徴です。&lt;/p&gt;

&lt;p&gt;このセクションでは、Unityのシェーダーのコードを記述してレイマーチングを実装します。
レイマーチングの基礎から応用まで解説するために、合計13個のサンプルシーンを用意しました。
少しずつ処理を加えることで、一歩ずつレベルアップしながら理解を深められるチュートリアル形式のサンプルシーンになっています。&lt;/p&gt;

&lt;p&gt;サンプルプロジェクトは、筆者のGitHubにて公開しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/UnityBible2-RaymarchingTutorial&#34;&gt;https://github.com/gam0022/UnityBible2-RaymarchingTutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このセクションで学べることとそのポイントを、以下にまとめておきます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;レイマーチングのアルゴリズムと本質

&lt;ul&gt;
&lt;li&gt;レイマーチングは魔法の道具ではなく、単なる衝突判定の手法&lt;/li&gt;
&lt;li&gt;数式（距離関数）によるプロシージャルなモデリング手法&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コンピュータグラフィックスの基礎

&lt;ul&gt;
&lt;li&gt;レイマーチングが扱う範囲はあくまで衝突判定&lt;/li&gt;
&lt;li&gt;ライティングは通常のシェーダーとまったく同じように実装する必要がある&lt;/li&gt;
&lt;li&gt;Unityエンジンのシーンやライティング機能を利用せずに、グラフィックスを描画する一連の流れを学べるため、コンピュータグラッフィックスの学習教材としても有用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;執筆の裏話&#34;&gt;執筆の裏話&lt;/h2&gt;

&lt;p&gt;執筆の裏話としては作図にレイマーチングを利用しました。&lt;/p&gt;

&lt;p&gt;よくあるレイトレーシングの原理（スクリーン上のピクセルに対応する向きのレイを飛ばして交差判定）を解説するための図が欲しかったので、レイマーチングで作図しました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;シェーダーは最強の作図ツールなので、&lt;br&gt;レイトレーシングの原理を説明するための図をUnityシェーダーだけで作りました。 &lt;a href=&#34;https://t.co/VuLBhoqEaY&#34;&gt;pic.twitter.com/VuLBhoqEaY&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1343070779961839617?ref_src=twsrc%5Etfw&#34;&gt;December 27, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;ちゃんとアニメーションもできるように作り込んだのですが、書籍だと静止画になってしまうのが残念ですね。&lt;/p&gt;

&lt;h1 id=&#34;timelineによる映像制作&#34;&gt;Timelineによる映像制作&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/00_Top.jpg&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/00_Top.jpg&#34; alt=&#34;Timelineによる映像制作&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このセクションでは、Unityの&lt;a href=&#34;https://docs.unity3d.com/ja/2019.2/Manual/TimelineOverview.html&#34;&gt;Timeline&lt;/a&gt;を利用した映像作品の制作について解説しました。&lt;/p&gt;

&lt;p&gt;このセクションで学べる項目は、以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hecomi/uRaymarching&#34;&gt;uRaymarching&lt;/a&gt;を利用したレイマーチング&lt;/li&gt;
&lt;li&gt;Post-processing Stackの導入からビルトインエフェクトの利用、カスタムエフェクトの作成まで&lt;/li&gt;
&lt;li&gt;Timelineの基本からカスタムトラックの作成まで&lt;/li&gt;
&lt;li&gt;Cinemachineの基本的な使い方から、Post-processing Stackとの連携まで&lt;/li&gt;
&lt;/ul&gt;

&lt;!--
このセクションのサンプルシーンは、以下の各バージョンで作成しています。

- Unity 2020.1.8f1
- uRaymarching: v2.1.1
- Post-processing Stack（v2）2.3.0
- Timeline 1.3.6
- Cinemachine 2.6.3
- TextMeshPro 3.0.3
- Unity Recorder 2.5.2
--&gt;

&lt;p&gt;映像の作成のためには、数多くのUnityの機能とAssetを組み合わせる必要があります。&lt;/p&gt;

&lt;p&gt;それぞれのUnityの機能とAssetにフォーカスを当てた合計12個のサンプルシーンを用意しました。
サンプルシーンはチュートリアル形式で、一歩ずつレベルアップしながら理解を深められるようになっています。&lt;/p&gt;

&lt;p&gt;サンプルプロジェクトは、筆者のGitHubで公開しています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gam0022/UnityBible2-TimelineTutorial&#34;&gt;https://github.com/gam0022/UnityBible2-TimelineTutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-05-27-unity-bible2/12_BeatSync.gif&#34; alt=&#34;サンプル12 音楽と同期して演出をブラッシュアップ&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;執筆の裏話-1&#34;&gt;執筆の裏話&lt;/h2&gt;

&lt;p&gt;これも執筆の裏話になりますが、&lt;strong&gt;デモのメイキングを書籍として出版する&lt;/strong&gt; という個人的な試みに今回はチャレンジしました。&lt;/p&gt;

&lt;p&gt;このツイートが伏線でした。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;RevisionのWriteup先には意外な &amp;quot;媒体&amp;quot; を予定しています&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1379103521409101826?ref_src=twsrc%5Etfw&#34;&gt;April 5, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;サンプルの完成形のデモが『Secret stage BOSS』です。Revision2021のPC Demo Compoで初リリースしました。&lt;/p&gt;

&lt;p&gt;グラフィックスは私（&lt;a href=&#34;https://twitter.com/gam0022/&#34;&gt;@gam0022&lt;/a&gt;）、サウンドはさだきちさん（&lt;a href=&#34;https://twitter.com/sadakkey&#34;&gt;@sadakkey&lt;/a&gt;）が担当しました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&amp;quot;Secret stage BOSS&amp;quot; by &lt;a href=&#34;https://twitter.com/gam0022?ref_src=twsrc%5Etfw&#34;&gt;@gam0022&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://twitter.com/sadakkey?ref_src=twsrc%5Etfw&#34;&gt;@sadakkey&lt;/a&gt;&lt;br&gt;&lt;br&gt;Our new PC Demo for &lt;a href=&#34;https://twitter.com/hashtag/Revision2021?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#Revision2021&lt;/a&gt; (&lt;a href=&#34;https://twitter.com/revision_party?ref_src=twsrc%5Etfw&#34;&gt;@revision_party&lt;/a&gt;)&lt;br&gt;&lt;br&gt;It&amp;#39;s a Massive Greetings to &amp;quot;2nd stage BOSS&amp;quot; &lt;a href=&#34;https://t.co/vVWJJB4cyS&#34;&gt;pic.twitter.com/vVWJJB4cyS&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1378967812463501313?ref_src=twsrc%5Etfw&#34;&gt;April 5, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;『Secret stage BOSS』は&lt;a href=&#34;https://youtu.be/SFoyJED5A4s&#34;&gt;『2nd stage BOSS by 0x4015&amp;amp;YET11』&lt;/a&gt;というデモシーン歴史に残る伝説級のデモのオマージュ作品です。&lt;/p&gt;

&lt;p&gt;自機やボスが登場するシューティングゲーム風のストーリーを、自分たちなりのビジュアルと音楽のスタイルで再現しました。&lt;/p&gt;

&lt;div class=&#34;movie-wrap&#34;&gt;
&lt;iframe width=&#34;1920&#34; height=&#34;1080&#34; src=&#34;https://www.youtube.com/embed/srO7IxNckZ8&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;GitHub上でUnityプロジェクトを丸ごと公開しているので、もし興味があれば参考にしてください。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;You can see the source code &amp;amp; Unity project on GitHub!&lt;br&gt;&lt;br&gt;ソースコードとUnityプロジェクトをGitHubで公開しました！&lt;a href=&#34;https://t.co/dQJV35DGKB&#34;&gt;https://t.co/dQJV35DGKB&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1378975301456130049?ref_src=twsrc%5Etfw&#34;&gt;April 5, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;6年前にレイマーチングと出会ってから、レイマーチングの面白さに魅せられ続け、レイマーチングに関するさまざまな情報を発信してきました。
今回、Unityの一般ユーザー向けの書籍でレイマーチングについて解説をする機会をいただけたことをとても光栄に思います。
これまでシェーダーと縁がなかった方にもシェーダーに興味をもってもらえれば幸いです。&lt;/p&gt;

&lt;p&gt;日本語で書かれたレイマーチングの入門情報はかなり充実してきましたが、その次のステップの情報が不足しているように感じていました。
本書ではレイマーチングの中級者向けの情報として、距離関数によるモデリングや本格的なライティングまで解説しました。
レイマーチングで球体のレンダリングはできたけど、その次のステップが分からないという方にぜひ読んでいただきたいです。&lt;/p&gt;

&lt;p&gt;本書は定価8580円と気軽に購入しづらいかもしれませんが、&lt;strong&gt;フルカラーの1112ページ、扱うテーマの広さ、得られる情報の密度&lt;/strong&gt;を踏まえると妥当（むしろお買い得！）な値段だと思います。
初版部数はAmazonでの予約数をもとに決まるそうなので、ぜひ&lt;a href=&#34;https://amzn.to/3oe2agf&#34;&gt;Amazonから予約&lt;/a&gt;をお願いします！&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;リアルタイムレンダリング 第4版よりもページ数が多いことに気がついて驚いています。 &lt;a href=&#34;https://t.co/zJGUYOm8XL&#34;&gt;https://t.co/zJGUYOm8XL&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1393040315762634755?ref_src=twsrc%5Etfw&#34;&gt;May 14, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;追記-2021-08-21&#34;&gt;追記（2021-08-21）&lt;/h1&gt;

&lt;p&gt;7/29の「Unityゲーム プログラミング・バイブル 2nd Generation 出版記念トーク グラフィックス編」にゲスト出演しました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://learning.unity3d.jp/7437/&#34;&gt;Unityゲーム プログラミング・バイブル 2nd Generation 出版記念トーク グラフィックス編&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Windows Terminalの背景でレイマーチング</title>
      <link>https://gam0022.net/blog/2021/03/08/raymarching-in-windows-terminal/</link>
      <pubDate>Mon, 08 Mar 2021 01:00:00 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2021/03/08/raymarching-in-windows-terminal/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gam0022.net/images/posts/2021-02-26-raymarching-in-windows-terminal/raymarching-in-windows-terminal.png&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2021-02-26-raymarching-in-windows-terminal/raymarching-in-windows-terminal.jpg&#34; alt=&#34;Raymarching in Windows Terminal&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Windows Terminal 1.6から任意のHLSLのPixel Shadersを実行できるようになったので、Windows Terminalの背景でレイマーチングを実行してみました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Raymarching in Windows Terminal&lt;br&gt;&lt;br&gt;Windows Terminal 1.6 から任意の Pixel Shaders を実行できるようになったので、Windows Terminal の背景でレイマーチングを実行してみた🎉 これは楽しすぎる🤣 &lt;a href=&#34;https://t.co/WX2JqUZtuL&#34;&gt;pic.twitter.com/WX2JqUZtuL&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1361485111473045505?ref_src=twsrc%5Etfw&#34;&gt;February 16, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;2021-02-16のツイート時点では、Windows Terminal 1.6はまだPreview版なので、GitHubのReleasesページから入手する必要がありました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/terminal/releases/tag/v1.6.10412.0&#34;&gt;https://github.com/microsoft/terminal/releases/tag/v1.6.10412.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2021-03-07現在では、Windows Terminal 1.6からPreviewが外れてMicrosoft Storeから入手できるようになりました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.microsoft.com/ja-jp/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab&#34;&gt;Windows Terminal を入手 - Microsoft Store ja-JP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Windows TerminalのPixel Shaders機能の詳細については、公式ドキュメントをご覧ください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/microsoft/terminal/tree/main/samples/PixelShaders&#34;&gt;https://github.com/microsoft/terminal/tree/main/samples/PixelShaders&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任意のHLSLのシェーダーのファイルを作成して、Windows Terminalのsettings.jsonの &lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; からHLSLファイルのパスを設定するだけで、気軽に任意のシェーダーを実行できます。素晴らしい！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;profiles&amp;quot;:
  {
    &amp;quot;defaults&amp;quot;:
    {
      &amp;quot;experimental.pixelShaderPath&amp;quot;: &amp;quot;C:\\Users\\gam0022\\Dropbox\\windows-terminal\\terminal\\samples\\PixelShaders\\Raymarching.hlsl&amp;quot;
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;レイマーチング用のシェーダーはUnityで下書きしたものをWindows Terminal用に移植して実装しました。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Raymarching in Windows Terminal のシェーダーを公開しました。&lt;br&gt;&lt;br&gt;（シェーダー初心者にも優しい）日本語コメントつき！&lt;a href=&#34;https://t.co/GPEpIlHOyD&#34;&gt;https://t.co/GPEpIlHOyD&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1361495940356476929?ref_src=twsrc%5Etfw&#34;&gt;February 16, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;HLSLのエラーの行番号が表示されないので、複雑なシェーダーを書くのはちょっと苦労しました。&lt;/p&gt;

&lt;p&gt;基本的にはUnityのShaderLab用のプロパティや &lt;code&gt;_LightColor0&lt;/code&gt; などのビルドインのシェーダー変数を定数（static const）として宣言する修正だけで移植できました。&lt;/p&gt;

&lt;p&gt;Windows Terminal用のPixel Shadersでは、以下のテクスチャのサンプラーや定数が定義されていました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// The terminal graphics as a texture
// ターミナルの文字などを含んだターミナルのレンダリング結果のサンプラー
Texture2D shaderTexture;
SamplerState samplerState;

// Terminal settings such as the resolution of the texture
cbuffer PixelShaderSettings {
  // The number of seconds since the pixel shader was enabled
  // 秒単位の時間
  float Time;

  // UI Scale
  // UIのスケール
  float Scale;
  
  // Resolution of the shaderTexture
  // ピクセル単位の背景の解像度
  float2 Resolution;
  
  // Background color as rgba
  // 背景の色
  float4 Background;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shaderTexture&lt;/code&gt; はターミナルの文字などを含んだターミナルのレンダリング結果のサンプラーになるので、今回は背景に加算合成する形でシェーダーを実装しました（加算合成なので後からレイマーチングを加算しても結果は同じになるため、描画順を気にしなてくて良い）。&lt;/p&gt;

&lt;h1 id=&#34;hlslのホットリロードでシェーダーライブコーディング環境を実現&#34;&gt;HLSLのホットリロードでシェーダーライブコーディング環境を実現&lt;/h1&gt;

&lt;p&gt;Windows Terminal 1.6の挙動では、シェーダーを再コンパイルして結果を更新するために以下の手順が必要だったので、ライブコーディングには不向きでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; で指定したHLSLシェーダーに差分を出してファイル保存&lt;/li&gt;
&lt;li&gt;Windows Terminalの &lt;code&gt;settings.json&lt;/code&gt; の &lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; の値に差分を出してファイル保存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最初の動画ではシェーダーの描画結果をリアルタイムで更新するために、Vimで2つのファイルを同時編集することで、リアルタイムにライブコーディングっぽいことをしていましたが、かなり操作が忙しいので非実用的でした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Vimの左側ペイン: HLSLのシェーダー&lt;/li&gt;
&lt;li&gt;Vimの右側ペイン: Windows Terminalのsettings.json&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そこで、HLSLの更新を検知して、Windows Terminalの &lt;code&gt;settings.json&lt;/code&gt; を書き換えることで、HLSLのホットリロードを実現するスクリプトをnode.jsで実装しました。&lt;/p&gt;

&lt;p&gt;これによって、Windows Terminalの背景でHLSLシェーダーライブコーディングを実現できるようになりました！&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;Windows Terminal 上のHLSLシェーダーライブコーディング環境を実現するスクリプトをGitHubに公開しました！&lt;br&gt;&lt;br&gt;&amp;gt; HLSLの変更を監視して、settings.json を書き換え&lt;a href=&#34;https://t.co/hjB2MqgsSx&#34;&gt;https://t.co/hjB2MqgsSx&lt;/a&gt;&lt;/p&gt;&amp;mdash; がむ (@gam0022) &lt;a href=&#34;https://twitter.com/gam0022/status/1361706800282656769?ref_src=twsrc%5Etfw&#34;&gt;February 16, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Windows Terminalの &lt;code&gt;settings.json&lt;/code&gt; に毎回差分を出すために、HLSLファイルをコピーした一時ファイルを作成して、元のファイルのパスと一時ファイルのパスを交互に切り替えて &lt;code&gt;experimental.pixelShaderPath&lt;/code&gt; に設定するような実装としました。&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;Windows TerminalというMicrosoft公式のアプリ上でHLSLシェーダーライブコーディング環境を実現できるのは熱いですね！楽しい！！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Unity] Y軸ビルボードシェーダーの実装と解説</title>
      <link>https://gam0022.net/blog/2019/07/23/unity-y-axis-billboard-shader/</link>
      <pubDate>Tue, 23 Jul 2019 09:30:09 +0900</pubDate>
      
      <guid>https://gam0022.net/blog/2019/07/23/unity-y-axis-billboard-shader/</guid>
      <description>&lt;h1 id=&#34;改訂版の記事を書きました-2021-12-23&#34;&gt;改訂版の記事を書きました（2021-12-23）&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;この記事の方法は古いので、改訂版を参考にしてください。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gam0022.net/blog/2021/12/23/unity-urp-billboard-shader/&#34;&gt;[Unity][URP] Y軸ビルボードシェーダー | gam0022.net&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;こんな感じのY軸のビルボードをC#スクリプトを使わずに、シェーダーだけで実装しました（Unity 2018.3.12f1）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/billboard_y_axis.gif&#34; alt=&#34;Y軸ビルボード&#34; /&gt;&lt;/p&gt;

&lt;p&gt;GitHubリポジトリ: &lt;a href=&#34;https://github.com/gam0022/unity-legacy-render-pipeline-experiments/blob/master/Assets/Experiments/Billboard/Billboard.shader#L51-L82&#34;&gt;gam0022/unity-legacy-render-pipeline-experiments/blob/master/Assets/Experiments/Billboard&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;この記事の要約&#34;&gt;この記事の要約&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;頂点シェーダーでView行列の回転（カメラに応じた回転）をスキップすれば、ビルボードができる&lt;/li&gt;
&lt;li&gt;Unityは左手系座標だが、 &lt;strong&gt;View空間では右手系座標&lt;/strong&gt; なので、View変換をスキップするときには自前でZの符号を反転する必要がある&lt;/li&gt;
&lt;li&gt;Y軸のビルボードが必要なら、View行列から回転行列のY軸成分のみを抽出した行列を作れば良い&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;シェーダーで実装するメリット&#34;&gt;シェーダーで実装するメリット&lt;/h1&gt;

&lt;p&gt;シェーダーでビルボードを計算するメリットはたくさんあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VRChatなどユーザのC#スクリプトが使えない環境でも動作する&lt;/li&gt;
&lt;li&gt;シーンビュー上でも動作する&lt;/li&gt;
&lt;li&gt;GPU（頂点シェーダー）でビルボード計算ができる

&lt;ul&gt;
&lt;li&gt;ビルボード計算のためのCPU負荷が全くかからない&lt;/li&gt;
&lt;li&gt;板ポリの頂点数は4なので、頂点シェーダーで多少重い処理をしても、GPU負荷への影響はわずか&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;シェーダーのコード-全体&#34;&gt;シェーダーのコード（全体）&lt;/h1&gt;

&lt;p&gt;最終的なシェーダーのコードはこちらです。&lt;/p&gt;

&lt;p&gt;単体で動作しますので、コピペしてお使いいただけます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Unity Y-Axis Billboard Shader by @gam0022
// https://gam0022.net/blog/2019/07/23/unity-y-axis-billboard-shader/
Shader &amp;quot;Unlit/Billboard&amp;quot;
{
    Properties
    {
        _MainTex (&amp;quot;Texture&amp;quot;, 2D) = &amp;quot;white&amp;quot; {}
        [KeywordEnum(OFF, ALL_AXIS, Y_AXIS)] _BILLBOARD(&amp;quot;Billboard Mode&amp;quot;, Float) = 2
        _Cutoff (&amp;quot;Alpha Cutoff&amp;quot;, Range(0, 1)) = 0.5
    }
    SubShader
    {
        Tags{ &amp;quot;Queue&amp;quot; = &amp;quot;AlphaTest&amp;quot; &amp;quot;RenderType&amp;quot; = &amp;quot;TransparentCutout&amp;quot;
                &amp;quot;IgnoreProjector&amp;quot; = &amp;quot;True&amp;quot; &amp;quot;DisableBatching&amp;quot; = &amp;quot;True&amp;quot; }

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // make fog work
            #pragma multi_compile_fog

            #include &amp;quot;UnityCG.cginc&amp;quot;
            #pragma multi_compile _BILLBOARD_OFF _BILLBOARD_ALL_AXIS _BILLBOARD_Y_AXIS

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                UNITY_FOG_COORDS(1)
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            
            float _Cutoff;

            v2f vert (appdata v)
            {
                v2f o;

                #if _BILLBOARD_OFF
                {
                    // ビルボードなしの通常の座標変換
                    o.vertex = UnityObjectToClipPos(v.vertex);
                }
                #elif _BILLBOARD_ALL_AXIS
                {                   
                    // Meshの原点をModelView変換
                    float3 viewPos = UnityObjectToViewPos(float3(0, 0, 0));
                    
                    // スケールと回転（平行移動なし）だけModel変換して、View変換はスキップ
                    float3 scaleRotatePos = mul((float3x3)unity_ObjectToWorld, v.vertex);
                    
                    // scaleRotatePosを右手系に変換して、viewPosに加算
                    // 本来はView変換で暗黙的にZが反転されているので、
                    // View変換をスキップする場合は明示的にZを反転する必要がある
                    viewPos += float3(scaleRotatePos.xy, -scaleRotatePos.z);
                    
                    o.vertex = mul(UNITY_MATRIX_P, float4(viewPos, 1));
                }
                #elif _BILLBOARD_Y_AXIS
                {
                    // Meshの原点をModelView変換
                    float3 viewPos = UnityObjectToViewPos(float3(0, 0, 0));
                    
                    // スケールと回転（平行移動なし）だけModel変換して、View変換はスキップ
                    float3 scaleRotatePos = mul((float3x3)unity_ObjectToWorld, v.vertex);                
                    
                    // View行列から回転行列のY軸成分のみを抽出
                    float3x3 ViewRotateY = float3x3(
                        1, UNITY_MATRIX_V._m01, 0,
                        0, UNITY_MATRIX_V._m11, 0,
                        0, UNITY_MATRIX_V._m21, -1// Zの符号を反転して右手系に変換
                    );
                    viewPos += mul(ViewRotateY, scaleRotatePos);
                    
                    o.vertex = mul(UNITY_MATRIX_P, float4(viewPos, 1));
                }
                #endif

                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                UNITY_TRANSFER_FOG(o,o.vertex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                // sample the texture
                fixed4 col = tex2D(_MainTex, i.uv);
                clip(col.a - _Cutoff);
                
                // apply fog
                UNITY_APPLY_FOG(i.fogCoord, col);
                return col;
            }
            ENDCG
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h2 id=&#34;ビルボードのモードについて&#34;&gt;ビルボードのモードについて&lt;/h2&gt;

&lt;p&gt;このようにビルボードのモードをインスペクタで選択できます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/shader_inspector.png&#34; alt=&#34;シェーダーのインスペクタ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;それぞれの結果を並べました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;OFF: ビルボードなし&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;ALL_AXIS: 通常のビルボード&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Y_AXIS: Y軸のビルボード&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/billboard_off.gif&#34; alt=&#34;ビルボードなし&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/billboard_all_axis.gif&#34; alt=&#34;ビルボードあり&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/billboard_y_axis.gif&#34; alt=&#34;Y軸ビルボード&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;通常の描画&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上から見たときの違和感が大きい&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上から見たときの違和感を緩和できる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;コードの解説&#34;&gt;コードの解説&lt;/h1&gt;

&lt;p&gt;ここから、本題であるシェーダーの解説を行います。&lt;/p&gt;

&lt;h2 id=&#34;通常のビルボード&#34;&gt;通常のビルボード&lt;/h2&gt;

&lt;p&gt;通常のビルボードの頂点シェーダーの処理を抜粋しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#elif _BILLBOARD_ALL_AXIS
{                   
    // ①Meshの原点をModelView変換
    float3 viewPos = UnityObjectToViewPos(float3(0, 0, 0));
    
    // ②スケールと回転（平行移動なし）だけModel変換して、View変換はスキップ
    float3 scaleRotatePos = mul((float3x3)unity_ObjectToWorld, v.vertex);
    
    // ③scaleRotatePosを右手系に変換して、viewPosに加算
    // 本来はView変換で暗黙的にZが反転されているので、
    // View変換をスキップする場合は明示的にZを反転する必要がある
    viewPos += float3(scaleRotatePos.xy, -scaleRotatePos.z);
    
    // ④最後にプロジェクション変換
    o.vertex = mul(UNITY_MATRIX_P, float4(viewPos, 1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;①について&#34;&gt;①について&lt;/h3&gt;

&lt;p&gt;記事の冒頭で&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1.頂点シェーダーでView行列の回転（カメラに応じた回転）をスキップすれば、ビルボードができる&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;と書きましたが、厳密にはMeshの原点だけはView変換を行います。&lt;/p&gt;

&lt;p&gt;原点は回転の影響を受けないので、普通にModelView変換することで平行移動のみ適応できます。&lt;/p&gt;

&lt;h3 id=&#34;②について&#34;&gt;②について&lt;/h3&gt;

&lt;p&gt;Model行列よる平行移動は①で処理しているので、スケールと回転だけを各頂点に適応します。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(float3x3)unity_ObjectToWorld&lt;/code&gt; のように &lt;code&gt;float3x3&lt;/code&gt; でキャストすることで、平行移動の行列の成分を捨てることができます。&lt;/p&gt;

&lt;p&gt;列ベクトルの場合は4行目に平行移動の情報が入っていますが、キャストによって4列目の成分が消えるため、平行移動の成分が消えます。&lt;/p&gt;

&lt;h3 id=&#34;③について&#34;&gt;③について&lt;/h3&gt;

&lt;p&gt;①で&lt;code&gt;viewPos&lt;/code&gt; には原点のView空間の座標を代入しましたが、これに②で生成した各頂点の座標を加算しています。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;float3(scaleRotatePos.xy, -scaleRotatePos.z)&lt;/code&gt; のようにZ成分だけ符号を反転しているのは、冒頭の&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;2.Unityは左手系座標だが、 &lt;strong&gt;View空間では右手系座標&lt;/strong&gt; なので、View変換をスキップするときには自前でZの符号を反転する必要がある&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;という理由によるものです。&lt;/p&gt;

&lt;p&gt;左手系座標ではZ軸とカメラのforwardベクトルが同じ向きですが、右手系座標では反対向きになります。&lt;/p&gt;

&lt;p&gt;私はこのUnityの仕様を知らずに、かなり悩んでしまいました…&lt;/p&gt;

&lt;p&gt;私がネットで見つけたUnityのビルボードのシェーダーの実装のほとんどはZを反転する処理が抜けていました。
そのため、Box等の厚みのあるMeshに用いると、Cullingが反転して背面ポリゴンが描画される不具合がありました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Z反転なし&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Z反転あり&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/z_reverse_off.png&#34; alt=&#34;Z反転なし&#34; /&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://gam0022.net/images/posts/2019-07-22-unity-y-axis-billboard-shader/z_reverse_on.png&#34; alt=&#34;Z反転あり&#34; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;NG: Cullingが反転して背面ポリゴンが描画されている&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;OK: 正常に表面ポリゴンが描画されている&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;④について&#34;&gt;④について&lt;/h3&gt;

&lt;p&gt;View座標にプロジェクション行列を乗算すると、最終的なクリッピング座標を計算できます（定形処理）。&lt;/p&gt;

&lt;h2 id=&#34;y軸のビルボード&#34;&gt;Y軸のビルボード&lt;/h2&gt;

&lt;p&gt;Y軸のビルボードの頂点シェーダーの処理を抜粋しました。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#elif _BILLBOARD_Y_AXIS
{
    // ①Meshの原点をModelView変換
    float3 viewPos = UnityObjectToViewPos(float3(0, 0, 0));
    
    // ②スケールと回転（平行移動なし）だけModel変換して、View変換はスキップ
    float3 scaleRotatePos = mul((float3x3)unity_ObjectToWorld, v.vertex);                
    
    // ③View行列からY軸の回転だけ抽出した行列を生成
    float3x3 ViewRotateY = float3x3(
        1, UNITY_MATRIX_V._m01, 0,
        0, UNITY_MATRIX_V._m11, 0,
        0, UNITY_MATRIX_V._m21, -1// Zの符号を反転して右手系に変換
    );
    viewPos += mul(ViewRotateY, scaleRotatePos);
    
    // ④最後にプロジェクション変換
    o.vertex = mul(UNITY_MATRIX_P, float4(viewPos, 1));
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;①②④について&#34;&gt;①②④について&lt;/h3&gt;

&lt;p&gt;①②④については、通常のビルボードと全く同じ処理なので、説明を割愛します。&lt;/p&gt;

&lt;h3 id=&#34;③について-1&#34;&gt;③について&lt;/h3&gt;

&lt;p&gt;③の &lt;code&gt;ViewRotateY&lt;/code&gt; は冒頭で説明したこの行列です。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;3.Y軸のビルボードが必要なら、View行列から回転行列のY軸成分のみを抽出した行列を作れば良い&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;View行列から回転行列のY軸成分だけ抽出して、X軸とZ軸は変換しないようにしています。&lt;/p&gt;

&lt;p&gt;通常のビルボードと同様に、View空間では右手系座標とするために、3行3列目には -1 を指定しています。&lt;/p&gt;

&lt;h1 id=&#34;感想&#34;&gt;感想&lt;/h1&gt;

&lt;p&gt;ビルボードくらいサクッと実装できると思いきや、View空間が右手系座標になっているとは夢にも思わず、すこし苦戦しました。&lt;/p&gt;

&lt;p&gt;そこで動作原理を解説した日本語の記事を探したものの、ほとんど見当たらなかったため、今回筆を執った次第です。&lt;/p&gt;

&lt;p&gt;なるべく丁寧に解説したつもりでしたが、分かりにくい点や間違いがあればコメントやTwitterで教えてください。&lt;/p&gt;

&lt;p&gt;ちなみに今回の方法だとドローコールバッチングができないため、次回はドローコールを減らす解決策を紹介するかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;参考資料&#34;&gt;参考資料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Unity公式リファレンス

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/Manual//SL-BuiltinFunctions.html&#34;&gt;ビルトインシェーダーヘルパー機能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/Manual/SL-UnityShaderVariables.html&#34;&gt;ビルトインのシェーダー変数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.unity3d.com/ja/current/ScriptReference/Camera-worldToCameraMatrix.html&#34;&gt;Camera.worldToCameraMatrix&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ポイント: Note that camera space matches OpenGL convention: camera&amp;rsquo;s forward is the negative Z axis. This is different from Unity&amp;rsquo;s convention, where forward is the positive Z axis.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://edom18.hateblo.jp/entry/2019/01/04/153205&#34;&gt;Unityの行列の扱いとベクトルのオーダー周りについてまとめておく&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ポイント: UnityのC#は「列オーダー」。でもシェーダは「行オーダー」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://logicalbeat.jp/blog/929/&#34;&gt;【Unity】【数学】Unityでのビュー＆プロジェクション行列とプラットフォームの関係&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;ポイント: UnityのScene上は左手座標系が原則だが、シェーダ内の行列（UNITY_MATRIX_V）では右手座標系になっているという情報がある。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://marupeke296.com/DXG_No72_ViewProjInfo.html&#34;&gt;その72 ビュー・射影変換行列が持つ情報を抜き出そう&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Model行列・View行列・Projection行列の各成分が何だったか忘れたときに参考になります&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;既存のビルボードのシェーダー実装

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/kaiware007/8ebad2d28638ff83b6b74970a4f70c9a#file-billboard-shader-L47-L50&#34;&gt;Simple Billboard shader for Unity&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;NOTE: Cullingの不具合あり&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/Unity3D/comments/ahqbod/a_billboard_sprite_shader_in_only_one_axis/eeieb6q/&#34;&gt;A billboard sprite shader in only one axis&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;NOTE: 逆行列（転置行列）でViewのXZの回転を打ち消すアプローチなので、計算に無駄がある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;利用したテクスチャ素材

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pngall.com/tree-png/download/23754&#34;&gt;Tree PNG Clipart Background&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.deviantart.com/fabooguy/art/Dirt-Ground-Texture-Tileable-2048x2048-441212191&#34;&gt;Dirt/Ground Texture [Tileable | 2048x2048]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
